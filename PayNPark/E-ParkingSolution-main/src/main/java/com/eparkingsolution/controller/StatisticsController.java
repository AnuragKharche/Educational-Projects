package com.eparkingsolution.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;

import com.eparkingsolution.model.CarPark;
import com.eparkingsolution.model.ParkingSpace;
import com.eparkingsolution.model.Transaction;
import com.eparkingsolution.model.User;
import com.eparkingsolution.repository.*;
import com.eparkingsolution.service.UserService;

import java.security.Principal;
import java.text.DecimalFormat;
import java.time.DayOfWeek;
import java.time.Duration;
import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Controller
public class StatisticsController {

    @Autowired
    private UserService userService;

    @Autowired
    private TransactionRepository transactionRepository;

    @Autowired
    private CardRepository cardRepository;
    @Autowired
    private CarParkRepository carParkRepository;

    @Autowired
    private ParkingSpaceRepository parkingSpaceRepository;
    @Autowired
    private UserRepository userRepository;

    @GetMapping("/parkingOwnerStatistics")
    public String parkingOwnerStatistics(Model model, Principal principal) {
        String email = principal.getName();
        User user = userService.findByUsername(email);

//         Total number of car parks owned by the user
        int totalCarParks = user.getCarParks().size();
        model.addAttribute("totalCarParks", totalCarParks);

//         Total number of parking spaces in all the car parks owned by the user
        int totalParkingSpaces = user.getCarParks().stream()
                .mapToInt(carPark -> carPark.getParkingSpace().size())
                .sum();
        model.addAttribute("totalParkingSpaces", totalParkingSpaces);

// Percentage of car parks with disabled spaces
        int carParksWithDisabledSpaces = 0;
        for (CarPark carPark : user.getCarParks()) {
            if (carPark.getDisabledSpaces().equals("Yes")) {
                carParksWithDisabledSpaces++;
            }
        }
        int percentageWithDisabledSpaces = totalCarParks > 0 ? carParksWithDisabledSpaces * 100 / totalCarParks : 0;
        model.addAttribute("percentageWithDisabledSpaces", percentageWithDisabledSpaces);


//        Average price for the parking spaces
        Map<String, Double> averagePriceByCarPark = new HashMap<>();
        DecimalFormat decimalFormat = new DecimalFormat("#.00");
        user.getCarParks().forEach(carPark -> {
            double averagePrice = carPark.getParkingSpace().stream()
                    .mapToDouble(ParkingSpace::getPrice)
                    .average()
                    .orElse(0);
            String formattedAveragePrice = decimalFormat.format(averagePrice);
            averagePriceByCarPark.put(carPark.getName(), Double.parseDouble(formattedAveragePrice));
        });

        double overallAveragePrice = averagePriceByCarPark.values().stream()
                .mapToDouble(Double::doubleValue)
                .average()
                .orElse(0);
        String formattedOverallAveragePrice = decimalFormat.format(overallAveragePrice);

        model.addAttribute("averagePriceByCarPark", averagePriceByCarPark);
        model.addAttribute("overallAveragePrice", Double.parseDouble(formattedOverallAveragePrice));




//         Total revenue generated by the user's car parks
        double totalRevenue = user.getCarParks().stream()
                .flatMap(carPark -> carPark.getParkingSpace().stream())
                .flatMap(parkingSpace -> parkingSpace.getTransaction().stream())
                .mapToDouble(Transaction::getAmount)
                .sum();

        DecimalFormat decimalFormatt = new DecimalFormat("#.00");
        String formattedTotalRevenue = decimalFormatt.format(totalRevenue);

        model.addAttribute("totalRevenue", Double.parseDouble(formattedTotalRevenue));


//         License plate with most transactions
        Map<String, Long> licensePlateCount = new HashMap<>();
        for (Transaction transaction : user.getTransactions()) {
            String licensePlate = transaction.getLicensePlate();
            if (licensePlate != null && !licensePlate.isEmpty()) {
                licensePlateCount.put(licensePlate, licensePlateCount.getOrDefault(licensePlate, 0L) + 1);
            }
        }
        String mostFrequentLicensePlate = licensePlateCount.entrySet().stream()
                .max(Map.Entry.comparingByValue())
                .map(Map.Entry::getKey)
                .orElse(null);
        model.addAttribute("mostFrequentLicensePlate", mostFrequentLicensePlate);


        // Most booked plate
        List<Object[]> result = transactionRepository.getMostBookedLicensePlate(user.getId());
        if (result != null && !result.isEmpty() && result.get(0) != null && result.get(0).length > 0) {
            String licensePlate = (String) result.get(0)[0];
            long count = (long) result.get(0)[1];
            model.addAttribute("mostBookedLicensePlate", licensePlate);
            model.addAttribute("mostBookedLicensePlateCount", count);
        }


        // Percentage of disabled parking spaces
        int totalDisabledSpaces = 0;
        int totalSpaces = 0;

        for(CarPark carPark : user.getCarParks()) {
            for(ParkingSpace parkingSpace : carPark.getParkingSpace()) {
                totalSpaces++;
                if(parkingSpace.getDisabledSpace().equals("Yes")) {
                    totalDisabledSpaces++;
                }
            }
        }

        int percentageOfDisabledSpaces = totalSpaces > 0 ? totalDisabledSpaces * 100 / totalSpaces : 0;
        model.addAttribute("percentageOfDisabledSpaces", percentageOfDisabledSpaces);


//        Highest transaction for each car park
        // Get the user's carparks
        List<CarPark> carParks = user.getCarParks();

//         Find the highest transaction amount for the user's carparks
        DecimalFormat decimalFormats = new DecimalFormat("#.00");

        double highestTransactionAmount = carParks.stream()
                .flatMap(carPark -> carPark.getParkingSpace().stream())
                .flatMap(parkingSpace -> parkingSpace.getTransaction().stream())
                .mapToDouble(Transaction::getAmount)
                .max()
                .orElse(0);

        String formattedHighestTransactionAmount = decimalFormats.format(highestTransactionAmount);

        model.addAttribute("highestTransactionAmount", Double.parseDouble(formattedHighestTransactionAmount));



//         Get a list of all transactions
        List<Transaction> transactions = transactionRepository.findAll();

// Create a map to store the count of transactions for each day of the week
        Map<DayOfWeek, Integer> transactionCountsByDayOfWeek = new HashMap<>();
        for (Transaction transaction : transactions) {
            DayOfWeek dayOfWeek = transaction.getStartDate().getDayOfWeek();
            int countt = transactionCountsByDayOfWeek.getOrDefault(dayOfWeek, 0);
            transactionCountsByDayOfWeek.put(dayOfWeek, countt + 1);
        }

// Find the day of the week with the highest transaction count
        DayOfWeek busiestDayOfWeek = transactionCountsByDayOfWeek.entrySet().stream()
                .max(Map.Entry.comparingByValue())
                .map(Map.Entry::getKey)
                .orElse(null);

// Add the result to the model
        model.addAttribute("busiestDayOfWeek", busiestDayOfWeek);



        if (!transactions.isEmpty()) {
            // (Previous code remains unchanged)

            // Calculate the average transaction duration in minutes
            long totalDuration = 0;
            for (Transaction transaction : transactions) {
                LocalDateTime start = LocalDateTime.of(transaction.getStartDate(), transaction.getStartTime());
                LocalDateTime end = LocalDateTime.of(transaction.getEndDate(), transaction.getEndTime());
                long durationInMinutes = ChronoUnit.MINUTES.between(start, end);
                totalDuration += durationInMinutes;
            }
            int averageDuration = transactions.size() > 0 ? (int) (totalDuration / transactions.size()) : 0;

            // Format the result as days, hours, and minutes
            int days = averageDuration / (24 * 60);
            int hours = (averageDuration % (24 * 60)) / 60;
            int minutes = averageDuration % 60;
            String formattedDuration = String.format("%d days, %d hours, %d minutes", days, hours, minutes);

            // Add the result to the model
            model.addAttribute("averageTransactionDuration", formattedDuration);
        }
        return "statisticsParkingOwner";
    }

    @GetMapping("/siteAdministratorStatistics")
    public String siteAdministratorStatistics(Model model) {

//         Total number of car parks owned by the user
        int totalCarParksSA = carParkRepository.findAll().size();
        model.addAttribute("totalCarParksSA", totalCarParksSA);

//         Total number of parking spaces in all the car parks owned by the user
        int totalParkingSpacesSA = parkingSpaceRepository.findAll().size();
        model.addAttribute("totalParkingSpacesSA", totalParkingSpacesSA);

// Percentage of car parks with disabled spaces
        int carParksWithDisabledSpaces = 0;
        for (CarPark carPark : carParkRepository.findAll()) {

                if (carPark.getDisabledSpaces().equals("Yes")) {
                    carParksWithDisabledSpaces++;
                }
            }

        int percentageWithDisabledSpaces = totalCarParksSA > 0 ? carParksWithDisabledSpaces * 100 / totalCarParksSA : 0;
        model.addAttribute("percentageWithDisabledSpaces", percentageWithDisabledSpaces);


//        Average price for the parking spaces
        double averagePrice = carParkRepository.findAll().stream()
                .flatMap(carPark -> carPark.getParkingSpace().stream())
                .mapToDouble(ParkingSpace::getPrice)
                .average()
                .orElse(0);
        model.addAttribute("averagePrice", String.format("%.2f", averagePrice));


//         Total revenue generated by the user's car parks
        double totalRevenue = carParkRepository.findAll().stream()
                .flatMap(carPark -> carPark.getParkingSpace().stream())
                .flatMap(parkingSpace -> parkingSpace.getTransaction().stream())
                .mapToDouble(Transaction::getAmount)
                .sum();
        model.addAttribute("totalRevenue", String.format("%.2f", totalRevenue));

//         License plate with most transactions
        Map<String, Long> licensePlateCount = new HashMap<>();
        for (Transaction transaction : transactionRepository.findAll()) {
            String licensePlate = transaction.getLicensePlate();
            if (licensePlate != null && !licensePlate.isEmpty()) {
                licensePlateCount.put(licensePlate, licensePlateCount.getOrDefault(licensePlate, 0L) + 1);
            }
        }
        String mostFrequentLicensePlate = licensePlateCount.entrySet().stream()
                .max(Map.Entry.comparingByValue())
                .map(Map.Entry::getKey)
                .orElse(null);
        model.addAttribute("mostFrequentLicensePlate", mostFrequentLicensePlate);


//         Percentage of disabled parking spaces
        int totalDisabledSpaces = 0;
        int totalSpaces = 0;

        for(CarPark carPark : carParkRepository.findAll()) {
            for(ParkingSpace parkingSpace : carPark.getParkingSpace()) {
                totalSpaces++;
                if(parkingSpace.getDisabledSpace().equals("Yes")) {
                    totalDisabledSpaces++;
                }
            }
        }

        int percentageOfDisabledSpaces = totalSpaces > 0 ? totalDisabledSpaces * 100 / totalSpaces : 0;
        model.addAttribute("percentageOfDisabledSpaces", percentageOfDisabledSpaces);


//        Highest transaction for each car park
//         Get the user's carparks
        List<CarPark> carParks = carParkRepository.findAll();

        // Find the highest transaction amount for the user's carparks
        double highestTransactionAmount = carParks.stream()
                .flatMap(carPark -> carPark.getParkingSpace().stream())
                .flatMap(parkingSpace -> parkingSpace.getTransaction().stream())
                .mapToDouble(Transaction::getAmount)
                .max()
                .orElse(0);

        model.addAttribute("highestTransactionAmount", String.format("%.2f", highestTransactionAmount));


//         Get a list of all transactions
        List<Transaction> transactions = transactionRepository.findAll();

// Create a map to store the count of transactions for each day of the week
        Map<DayOfWeek, Integer> transactionCountsByDayOfWeek = new HashMap<>();
        for (Transaction transaction : transactions) {
            DayOfWeek dayOfWeek = transaction.getStartDate().getDayOfWeek();
            int countt = transactionCountsByDayOfWeek.getOrDefault(dayOfWeek, 0);
            transactionCountsByDayOfWeek.put(dayOfWeek, countt + 1);
        }

// Find the day of the week with the highest transaction count
        DayOfWeek busiestDayOfWeek = transactionCountsByDayOfWeek.entrySet().stream()
                .max(Map.Entry.comparingByValue())
                .map(Map.Entry::getKey)
                .orElse(null);

// Add the result to the model
        model.addAttribute("busiestDayOfWeek", busiestDayOfWeek);


//         Calculate the average transaction duration in minutes
        long totalDuration = 0;
        for (Transaction transaction : transactions) {
            LocalDateTime start = LocalDateTime.of(transaction.getStartDate(), transaction.getStartTime());
            LocalDateTime end = LocalDateTime.of(transaction.getEndDate(), transaction.getEndTime());
            long durationInMinutes = ChronoUnit.MINUTES.between(start, end);
            totalDuration += durationInMinutes;
        }
        int averageDuration = transactions.size() > 0 ? (int) (totalDuration / transactions.size()) : 0;

// Format the result as days, hours, and minutes
        int days = averageDuration / (24 * 60);
        int hours = (averageDuration % (24 * 60)) / 60;
        int minutes = averageDuration % 60;
        String formattedDuration = String.format("%d days, %d hours, %d minutes", days, hours, minutes);

// Add the result to the model
        model.addAttribute("averageTransactionDuration", formattedDuration);

//        Number of users within the website
        List<User> users = userRepository.findAll();
        int numberOfUsers = users.size();
        model.addAttribute("numberOfAccounts", numberOfUsers);

//        Number of users that are drivers
        int numberOfDrivers = userRepository.findByRole("Driver").size();
        model.addAttribute("numberOfDrivers", numberOfDrivers);

        //        Number of users that are Parking Owners
        int numberOfPA = userRepository.findByRole("Parking Owner").size();
        model.addAttribute("numberOfPO", numberOfPA);

        //        Number of users that are Site Administrators
        int numberOfSA = userRepository.findByRole("Site Administrator").size();
        model.addAttribute("numberOfSA", numberOfSA);




        return "statisticsSiteAdministrator";
    }


}
